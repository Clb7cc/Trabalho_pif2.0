#include "keyboard.h"
#include "screen.h"
#include "timer.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

// Defini√ß√£o dos c√≥digos das teclas
enum {
  KEY_ESC = 27, //tecla ESC
  KEY_W = 119, //tecla W
  KEY_S = 115, //tecla S
  KEY_A = 97, //tecla A
  KEY_D = 100 //tecla D
};

// Estrutura de dados para os n√≥s da cobra
struct noparacobra {
  int Xno; //armazena a posi√ß√£o X da cabe√ßa da cobra
  int Yno; //armazena a posi√ß√£o Y da cabe√ßa da cobra
  struct noparacobra *next;
};

// Estrutura de dados para os n√≥s do ranking
struct ranking {
  int score;
  struct ranking *next;
};

// Fun√ß√£o para imprimir informa√ß√µes na parte inferior da tela
void printembaixo(int placar, int recorde, int tempo) {
  screenSetColor(YELLOW, DARKGRAY); //printa em amarelo com fundo cinza escuro
  int offsetX = MAXX + 5; //soma 5 ao MAXX, tirando as informa√ß√µes da tela
  int offsetY = MINY + 3; //soma 3 ao MINY, predefinindo para as configura√ß√µes do placar

  screenGotoxy(offsetX, offsetY); //vai para offset X e Y
  printf("| Placar : %d", placar);

  screenGotoxy(offsetX, offsetY + 2); //desce + 2 no Y em rela√ß√£o a placar
  printf("| Recorde : %d", recorde);

  screenGotoxy(offsetX, offsetY + 4); //desce + 2 no Y em rela√ß√£o a recorde
  printf("| Tempo vivo : %d", tempo);
}

// Fun√ß√£o para adicionar um novo n√≥ (parte do corpo) √† cobra
void addcobra(struct noparacobra **head, int x, int y) {
  if (*head == NULL) { //Se score for 0
    *head = (struct noparacobra *)malloc(sizeof(struct noparacobra));
    (*head)->Xno = x; // Define a coordenada X do novo n√≥
    (*head)->Yno = y; // Define a coordenada Y do novo n√≥
    (*head)->next = NULL; // Define proximo como NULL
  } 
  else { // se score n√£o for 0
    struct noparacobra *temp2 = *head; // Cria um ponteiro tempor√°rio apontando para a cabe√ßa da cobra
    struct noparacobra *novo = (struct noparacobra *)malloc(sizeof(struct noparacobra));
    novo->Xno = x;
    novo->Yno = y;
    while (temp2->next != NULL) { //Percorre todas as partes da cobra
      temp2 = temp2->next;
    }
    novo->next = NULL;
    temp2->next = novo; // Adiciona o novo n√≥ ao final da lista
  }
}

// Fun√ß√£o para imprimir a cobra na tela
void printcobra(struct noparacobra *head) {
  struct noparacobra *temp2 = head;
  while (temp2 != NULL) {
    screenSetColor(GREEN, DARKGRAY);
    screenGotoxy(temp2->Xno, temp2->Yno);
    printf("I");
    temp2 = temp2->next;
  }
}

// Fun√ß√£o para atualizar a posi√ß√£o da cobra na tela
void atualizarcobra(struct noparacobra *head) {
  struct noparacobra *temp2 = head;
  while (temp2 != NULL) {
    screenGotoxy(temp2->Xno, temp2->Yno);
    printf(" ");
    temp2 = temp2->next;
  }
}

// Fun√ß√£o para liberar a mem√≥ria alocada para os n√≥s da cobra
void freecobra(struct noparacobra **head) {
  struct noparacobra *temp2 = *head;
  while (temp2 != NULL) {
    struct noparacobra *temp1 = temp2;
    temp2 = temp2->next;
    free(temp1);
  }
}

// Fun√ß√£o para adicionar uma nova cabe√ßa √† cobra
void cobrandando(struct noparacobra **head, int x, int y) {
  struct noparacobra *newHead = (struct noparacobra *)malloc(sizeof(struct noparacobra));
  if (newHead == NULL) {
    exit(1);
  }

  newHead->Xno = x;
  newHead->Yno = y;
  newHead->next = *head;
  *head = newHead;

  struct noparacobra *temp1 = *head;
  while (temp1->next->next != NULL) {
    temp1 = temp1->next;
  }

  free(temp1->next);
  temp1->next = NULL;
}

// Fun√ß√£o para imprimir a ma√ß√£ na tela
void printmaca(int x, int y) {
  screenSetColor(RED, DARKGRAY);
  screenGotoxy(x, y);
  printf("O");
}

// Fun√ß√£o para verificar se a cobra colidiu consigo mesma
int baternocorpo(struct noparacobra *head, int x, int y) {
  struct noparacobra *temp2 = head;
  while (temp2 != NULL) {
    if (temp2->Xno == x && temp2->Yno == y) {
      return 1;
    }
    temp2 = temp2->next;
  }
  return 0;
}

// Fun√ß√£o para gerar aleatoriamente a posi√ß√£o da ma√ß√£
void randonmaca(int *x, int *y) {
  *x = rand() % (MAXX - MINX - 1) + MINX + 1;
  *y = rand() % (MAXY - MINY - 1) + MINY + 1;
  int naogerex = 6;
  int naogerey = 38;
  while ((*x <= naogerex || *y >= naogerey) || (*x >= 6 && *x <= 43 && *y >= 13 && *y <= 14)) {
    *x = rand() % (MAXX - MINX - 1) + MINX + 1;
    *y = rand() % (MAXY - MINY - 1) + MINY + 1;
  }
}

// Fun√ß√£o para adicionar uma pontua√ß√£o ao ranking
void rankingemordem(struct ranking **head, int score) {
  if (*head == NULL || score > (*head)->score) {
    struct ranking *novo = (struct ranking *)malloc(sizeof(struct ranking));
    novo->score = score;
    novo->next = *head;
    *head = novo;
  } else {
    rankingemordem(&((*head)->next), score);
  }
}

// Fun√ß√£o para adicionar as pontua√ß√µes ao arquivo
void addnoranking(struct ranking *head, FILE *in) {
  struct ranking *temp = head;
  while (temp != NULL) {
    int score = temp->score;
    if (fwrite(&score, sizeof(int), 1, in) != 1) {
      break;
    }
    temp = temp->next;
  }
}

// Fun√ß√£o para imprimir o ranking na tela
void printranking(struct ranking *head) {
  struct ranking *temp = head;
  int cont = 0;
  while (temp != NULL && (cont < 3)) {
    printf("%d¬∞ colocado: %d pontos\n", cont + 1, temp->score);
    temp = temp->next;
    cont++;
  }
}

// Fun√ß√£o para liberar a mem√≥ria alocada para a lista de ranking
void freeranking(struct ranking **head) {
  struct ranking *temp2 = *head;
  while (temp2 != NULL) {
    struct ranking *temp1 = temp2;
    temp2 = temp2->next;
    free(temp1);
  }
}

// Loop principal do jogo
void jogoLoop(struct noparacobra *head, int *dirX, int *dirY, int *placar, int *recorde, time_t tempoinicial, int PosMacaX, int PosMacaY) {
  int ch = 0;
  while (ch != KEY_ESC) {
    if (keyhit()) {
      ch = readch();
      switch (ch) {
        case KEY_W:
          if (*dirY != 1) {
            *dirX = 0;
            *dirY = -1;
          }
          break;
        case KEY_S:
          if (*dirY != -1) {
            *dirX = 0;
            *dirY = 1;
          }
          break;
        case KEY_A:
          if (*dirX != 1) {
            *dirX = -1;
            *dirY = 0;
          }
          break;
        case KEY_D:
          if (*dirX != -1) {
            *dirX = 1;
            *dirY = 0;
          }
          break;
      }
      screenUpdate();
    }
    if (timerTimeOver() == 1) {
      int newX = head->Xno + *dirX;
      int newY = head->Yno + *dirY;
      if (newX >= (MAXX) || newX <= MINX || newY >= MAXY || newY <= MINY) {
        break;
      }
      if (baternocorpo(head, newX, newY) == 1) {
        break;
      }
      if (newX == PosMacaX && newY == PosMacaY) {
        addcobra(&head, PosMacaX, PosMacaY);
        randonmaca(&PosMacaX, &PosMacaY);
        printmaca(PosMacaX, PosMacaY);
        (*placar)++;
      }
      atualizarcobra(head);
      cobrandando(&head, newX, newY);
      printcobra(head);
      screenUpdate();
      printembaixo(*placar, *recorde, (int)difftime(time(NULL), tempoinicial));
    }
  }
}

// Fun√ß√£o principal do programa
int main() {
  printf("          üêçüçé SNAKE GAME üçéüêç\n\n\n              Carregando...\n");
  sleep(3);
  struct noparacobra *head = NULL;
  static int ch = 0;
  int placar = 0;
  int dirX = 1, dirY = 0;
  FILE *in;

  // Inicializa√ß√£o dos m√≥dulos
  screenInit(1);
  keyboardInit();
  timerInit(80);

  // Adicionando a primeira parte da cobra
  addcobra(&head, 25, 7);
  // Inicializando o gerador de n√∫meros aleat√≥rios
  srand((unsigned int)time(NULL));
  // Gerando a posi√ß√£o inicial da ma√ß√£
  int PosMacaX = rand() % (MAXX - MINX) + MINX, PosMacaY = rand() % (MAXY - MINY) + MINY;
  // Imprimindo a ma√ß√£ na tela
  printmaca(PosMacaX, PosMacaY);
  screenUpdate();

  // Verificando o recorde do jogo
  int recorde = 0;
  in = fopen("rankfile.txt", "r");
  if (in != NULL) {
    while (fread(&placar, sizeof(int), 1, in) == 1) {
      if (placar > recorde) {
        recorde = placar;
      }
    }
    fclose(in);
  }

  // Inicializando o tempo do jogo
  time_t tempoinicial, tempovivo;
  int tempo = 0;
  tempoinicial = time(NULL);
  // Iniciando o loop do jogo
  jogoLoop(head, &dirX, &dirY, &placar, &recorde, tempoinicial, PosMacaX, PosMacaY);
  // Liberando a mem√≥ria alocada para a cobra
  freecobra(&head);
  keyboardDestroy();
  screenDestroy();
  // Abrindo o arquivo de ranking para escrita
  in = fopen("rankfile.txt", "a");
  // Escrevendo a pontua√ß√£o atual no arquivo
  fwrite(&placar, sizeof(int), 1, in);
  fclose(in);
  struct ranking *lista = NULL;
  // Lendo as pontua√ß√µes do arquivo e ordenando em ordem decrescente
  in = fopen("rankfile.txt", "r");
  while (fread(&placar, sizeof(int), 1, in) == 1) {
    rankingemordem(&lista, placar);
  }
  fclose(in);
  // Abrindo o arquivo de ranking para escrita
  in = fopen("rankfile.txt", "w");
  // Escrevendo as pontua√ß√µes ordenadas no arquivo
  addnoranking(lista, in);
  fclose(in);
  // Imprimindo o ranking na tela
  printranking(lista);
  // Liberando a mem√≥ria alocada para a lista de ranking
  freeranking(&lista);
  // Finalizando o timer
  timerDestroy();

  return 0;
}
