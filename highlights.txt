void addcobra(struct noparacobra **head, int x, int y) {
  if (*head == NULL) {
    *head = (struct noparacobra *)malloc(sizeof(struct noparacobra));
    (*head)->Xno = x;
    (*head)->Yno = y;
    (*head)->next = NULL;
  } 
  else {
    struct noparacobra *temp2 = *head;
    struct noparacobra *novo = (struct noparacobra *)malloc(sizeof(struct noparacobra));
    novo->Xno = x;
    novo->Yno = y;
    while (temp2->next != NULL) {
      temp2 = temp2->next;
    }
    novo->next = NULL;
    temp2->next = novo;
  }
}

int baternocorpo(struct noparacobra *head, int x, int y) {
  struct noparacobra *temp2 = head;
  while (temp2 != NULL) {
    if (temp2->Xno == x && temp2->Yno == y) {
      return 1;
    }
    temp2 = temp2->next;
  }
  return 0;
}

void atualizarcobra(struct noparacobra *head) {
  struct noparacobra *temp2 = head;
  while (temp2 != NULL) {
    screenGotoxy(temp2->Xno, temp2->Yno);
    printf(" ");
    temp2 = temp2->next;
  }
}

void rankingemordem(struct ranking **cabeca, int score) {
  if (*cabeca == NULL || score > (*cabeca)->score) {
    struct ranking *novo = (struct ranking *)malloc(sizeof(struct ranking));
    novo->score = score;
    novo->next = *cabeca;
    *cabeca = novo;
  } else {
    rankingemordem(&((*cabeca)->next), score);
  }
}


void randonmaca(int *x, int *y) {
  *x = rand() % (MAXX - MINX) + MINX + 1;
  *y = rand() % (MAXY - MINY) + MINY + 1;
  int naogerex = 6;
  int naogerey = 38;
  while ((*x < naogerex || *y > naogerey) || (*x > 6 && *x < 43 && *y > 13 && *y < 14)) {
    *x = rand() % (MAXX - MINX ) + MINX + 1;
    *y = rand() % (MAXY - MINY ) + MINY + 1;
  }
}

void teclado(struct noparacobra *head, int *dirX, int *dirY, int *placar, int *recorde, time_t tempoinicial, int PosMacaX, int PosMacaY) {
  int ch = 0;
  while (ch != KEY_ESC) {
    if (keyhit()) {
      ch = readch();
      switch (ch) {
        case KEY_W:
          if (*dirY != 1) {
            *dirX = 0;
            *dirY = -1;
          }
          break;
        case KEY_S:
          if (*dirY != -1) {
            *dirX = 0;
            *dirY = 1;
          }
          break;
        case KEY_A:
          if (*dirX != 1) {
            *dirX = -1;
            *dirY = 0;
          }
          break;
        case KEY_D:
          if (*dirX != -1) {
            *dirX = 1;
            *dirY = 0;
          }
          break;
      }
      screenUpdate();
    }
    if (timerTimeOver() == 1) {
      int newX = head->Xno + *dirX;
      int newY = head->Yno + *dirY;
      if (newX >= (MAXX) || newX <= MINX || newY >= MAXY || newY <= MINY) {
        break;
      }
      if (baternocorpo(head, newX, newY) == 1) {
        break;
      }
      if (newX == PosMacaX && newY == PosMacaY) {
        addcobra(&head, PosMacaX, PosMacaY);
        randonmaca(&PosMacaX, &PosMacaY);
        printmaca(PosMacaX, PosMacaY);
        (*placar)++;
      }
      atualizarcobra(head);
      cobrandando(&head, newX, newY);
      printcobra(head);
      screenUpdate();
      printembaixo(*placar, *recorde, (int)difftime(time(NULL), tempoinicial));
    }
  }
}